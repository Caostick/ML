#include <catch2/catch.hpp>

#include <ML/Network.h>
#include <ML/Utils.h>

namespace {
	auto GetMaxIdx(const double* vals, uint64_t num) -> uint64_t {
		uint64_t result = 0;
		double maxVal = vals[0];
		for (uint64_t i = 1; i < num; ++i) {
			if (vals[i] > maxVal) {
				maxVal = vals[i];
				result = i;
			}
		}
		return result;
	}
}

TEST_CASE("Iris Fisher Test") {
	struct Iris {
		double Len1 = 0.0f;
		double Wid1 = 0.0f;
		double Len2 = 0.0f;
		double Wid2 = 0.0f;

		int Idx;
	};

	/*const char* IrisNames[] = {
		"Iris-Setosa",
		"Iris-Versicolor",
		"Iris-Virginica"
	};*/

	const std::vector<Iris> dataset = {
		{5.1, 3.5, 1.4, 0.2, 0},
		{4.9, 3, 1.4, 0.2, 0},
		{4.7, 3.2, 1.3, 0.2, 0},
		{4.6, 3.1, 1.5, 0.2, 0},
		{5, 3.6, 1.4, 0.2, 0},
		{5.4, 3.9, 1.7, 0.4, 0},
		{4.6, 3.4, 1.4, 0.3, 0},
		{5, 3.4, 1.5, 0.2, 0},
		{4.4, 2.9, 1.4, 0.2, 0},
		{4.9, 3.1, 1.5, 0.1, 0},
		{5.4, 3.7, 1.5, 0.2, 0},
		{4.8, 3.4, 1.6, 0.2, 0},
		{4.8, 3, 1.4, 0.1, 0},
		{4.3, 3, 1.1, 0.1, 0},
		{5.8, 4, 1.2, 0.2, 0},
		{5.7, 4.4, 1.5, 0.4, 0},
		{5.4, 3.9, 1.3, 0.4, 0},
		{5.1, 3.5, 1.4, 0.3, 0},
		{5.7, 3.8, 1.7, 0.3, 0},
		{5.1, 3.8, 1.5, 0.3, 0},
		{5.4, 3.4, 1.7, 0.2, 0},
		{5.1, 3.7, 1.5, 0.4, 0},
		{4.6, 3.6, 1, 0.2, 0},
		{5.1, 3.3, 1.7, 0.5, 0},
		{4.8, 3.4, 1.9, 0.2, 0},
		{5, 3, 1.6, 0.2, 0},
		{5, 3.4, 1.6, 0.4, 0},
		{5.2, 3.5, 1.5, 0.2, 0},
		{5.2, 3.4, 1.4, 0.2, 0},
		{4.7, 3.2, 1.6, 0.2, 0},
		{4.8, 3.1, 1.6, 0.2, 0},
		{5.4, 3.4, 1.5, 0.4, 0},
		{5.2, 4.1, 1.5, 0.1, 0},
		{5.5, 4.2, 1.4, 0.2, 0},
		{4.9, 3.1, 1.5, 0.1, 0},
		{5, 3.2, 1.2, 0.2, 0},
		{5.5, 3.5, 1.3, 0.2, 0},
		{4.9, 3.1, 1.5, 0.1, 0},
		{4.4, 3, 1.3, 0.2, 0},
		{5.1, 3.4, 1.5, 0.2, 0},
		{5, 3.5, 1.3, 0.3, 0},
		{4.5, 2.3, 1.3, 0.3, 0},
		{4.4, 3.2, 1.3, 0.2, 0},
		{5, 3.5, 1.6, 0.6, 0},
		{5.1, 3.8, 1.9, 0.4, 0},
		{4.8, 3, 1.4, 0.3, 0},
		{5.1, 3.8, 1.6, 0.2, 0},
		{4.6, 3.2, 1.4, 0.2, 0},
		{5.3, 3.7, 1.5, 0.2, 0},
		{5, 3.3, 1.4, 0.2, 0},
		{7, 3.2, 4.7, 1.4, 1},
		{6.4, 3.2, 4.5, 1.5, 1},
		{6.9, 3.1, 4.9, 1.5, 1},
		{5.5, 2.3, 4, 1.3, 1},
		{6.5, 2.8, 4.6, 1.5, 1},
		{5.7, 2.8, 4.5, 1.3, 1},
		{6.3, 3.3, 4.7, 1.6, 1},
		{4.9, 2.4, 3.3, 1, 1},
		{6.6, 2.9, 4.6, 1.3, 1},
		{5.2, 2.7, 3.9, 1.4, 1},
		{5, 2, 3.5, 1, 1},
		{5.9, 3, 4.2, 1.5, 1},
		{6, 2.2, 4, 1, 1},
		{6.1, 2.9, 4.7, 1.4, 1},
		{5.6, 2.9, 3.6, 1.3, 1},
		{6.7, 3.1, 4.4, 1.4, 1},
		{5.6, 3, 4.5, 1.5, 1},
		{5.8, 2.7, 4.1, 1, 1},
		{6.2, 2.2, 4.5, 1.5, 1},
		{5.6, 2.5, 3.9, 1.1, 1},
		{5.9, 3.2, 4.8, 1.8, 1},
		{6.1, 2.8, 4, 1.3, 1},
		{6.3, 2.5, 4.9, 1.5, 1},
		{6.1, 2.8, 4.7, 1.2, 1},
		{6.4, 2.9, 4.3, 1.3, 1},
		{6.6, 3, 4.4, 1.4, 1},
		{6.8, 2.8, 4.8, 1.4, 1},
		{6.7, 3, 5, 1.7, 1},
		{6, 2.9, 4.5, 1.5, 1},
		{5.7, 2.6, 3.5, 1, 1},
		{5.5, 2.4, 3.8, 1.1, 1},
		{5.5, 2.4, 3.7, 1, 1},
		{5.8, 2.7, 3.9, 1.2, 1},
		{6, 2.7, 5.1, 1.6, 1},
		{5.4, 3, 4.5, 1.5, 1},
		{6, 3.4, 4.5, 1.6, 1},
		{6.7, 3.1, 4.7, 1.5, 1},
		{6.3, 2.3, 4.4, 1.3, 1},
		{5.6, 3, 4.1, 1.3, 1},
		{5.5, 2.5, 4, 1.3, 1},
		{5.5, 2.6, 4.4, 1.2, 1},
		{6.1, 3, 4.6, 1.4, 1},
		{5.8, 2.6, 4, 1.2, 1},
		{5, 2.3, 3.3, 1, 1},
		{5.6, 2.7, 4.2, 1.3, 1},
		{5.7, 3, 4.2, 1.2, 1},
		{5.7, 2.9, 4.2, 1.3, 1},
		{6.2, 2.9, 4.3, 1.3, 1},
		{5.1, 2.5, 3, 1.1, 1},
		{5.7, 2.8, 4.1, 1.3, 1},
		{6.3, 3.3, 6, 2.5, 2},
		{5.8, 2.7, 5.1, 1.9, 2},
		{7.1, 3, 5.9, 2.1, 2},
		{6.3, 2.9, 5.6, 1.8, 2},
		{6.5, 3, 5.8, 2.2, 2},
		{7.6, 3, 6.6, 2.1, 2},
		{4.9, 2.5, 4.5, 1.7, 2},
		{7.3, 2.9, 6.3, 1.8, 2},
		{6.7, 2.5, 5.8, 1.8, 2},
		{7.2, 3.6, 6.1, 2.5, 2},
		{6.5, 3.2, 5.1, 2, 2},
		{6.4, 2.7, 5.3, 1.9, 2},
		{6.8, 3, 5.5, 2.1, 2},
		{5.7, 2.5, 5, 2, 2},
		{5.8, 2.8, 5.1, 2.4, 2},
		{6.4, 3.2, 5.3, 2.3, 2},
		{6.5, 3, 5.5, 1.8, 2},
		{7.7, 3.8, 6.7, 2.2, 2},
		{7.7, 2.6, 6.9, 2.3, 2},
		{6, 2.2, 5, 1.5, 2},
		{6.9, 3.2, 5.7, 2.3, 2},
		{5.6, 2.8, 4.9, 2, 2},
		{7.7, 2.8, 6.7, 2, 2},
		{6.3, 2.7, 4.9, 1.8, 2},
		{6.7, 3.3, 5.7, 2.1, 2},
		{7.2, 3.2, 6, 1.8, 2},
		{6.2, 2.8, 4.8, 1.8, 2},
		{6.1, 3, 4.9, 1.8, 2},
		{6.4, 2.8, 5.6, 2.1, 2},
		{7.2, 3, 5.8, 1.6, 2},
		{7.4, 2.8, 6.1, 1.9, 2},
		{7.9, 3.8, 6.4, 2, 2},
		{6.4, 2.8, 5.6, 2.2, 2},
		{6.3, 2.8, 5.1, 1.5, 2},
		{6.1, 2.6, 5.6, 1.4, 2},
		{7.7, 3, 6.1, 2.3, 2},
		{6.3, 3.4, 5.6, 2.4, 2},
		{6.4, 3.1, 5.5, 1.8, 2},
		{6, 3, 4.8, 1.8, 2},
		{6.9, 3.1, 5.4, 2.1, 2},
		{6.7, 3.1, 5.6, 2.4, 2},
		{6.9, 3.1, 5.1, 2.3, 2},
		{5.8, 2.7, 5.1, 1.9, 2},
		{6.8, 3.2, 5.9, 2.3, 2},
		{6.7, 3.3, 5.7, 2.5, 2},
		{6.7, 3, 5.2, 2.3, 2},
		{6.3, 2.5, 5, 1.9, 2},
		{6.5, 3, 5.2, 2, 2},
		{6.2, 3.4, 5.4, 2.3, 2},
		{5.9, 3, 5.1, 1.8, 2}
	};

	const std::vector<int> rndSeq = { 41, 141, 119, 40, 45, 67, 106, 46, 131, 76, 112, 72, 104, 124, 33, 94, 52, 118, 84, 73, 21, 28, 71, 27, 48, 7, 77, 22, 96, 63, 59, 89, 24, 97, 14, 19, 20, 115, 12, 18, 143, 70, 2, 80, 114, 65, 93, 134, 149, 0, 75, 37, 47, 110, 113, 56, 126, 117, 35, 87, 132, 13, 26, 30, 57, 32, 100, 120, 142, 95, 9, 54, 111, 62, 103, 105, 127, 5, 128, 147, 64, 144, 29, 129, 31, 23, 90, 10, 107, 49, 66, 130, 88, 99, 137, 86, 74, 43, 145, 51, 101, 1, 98, 4, 83, 108, 102, 91, 16, 3, 79, 11, 81, 68, 36, 85, 92, 140, 44, 121, 78, 42, 34, 39, 136, 123, 116, 17, 50, 146, 69, 82, 25, 139, 138, 122, 148, 55, 61, 109, 125, 15, 8, 53, 135, 133, 38, 60, 58, 6 };


	ml::Network network(ml::ELossFunction::CategoricalCrossentropy);
	network.AddLayer(4);
	network.AddLayer(5, new ml::ActivationFunc_ReLU);
	network.AddLayer(3, new ml::ActivationFunc_Softmax);
	network.FillWeights(0.5);

	ml::Learning learning;

	const double alpha = 0.001;
	const int epochs = 4000;

	uint64_t numSucceeded = 0;
	uint64_t numTotal = 0;

	for (int i = 0; i < 14; ++i) {
		for (int e = 0; e < epochs; ++e) {
			const int idx = rndSeq[i * 10 + e % 10];

			ml::Vector expected({ 0.0, 0.0, 0.0 });
			expected[dataset[idx].Idx] = 1.0;

			const ml::Vector in({ dataset[idx].Len1, dataset[idx].Wid1, dataset[idx].Len2, dataset[idx].Wid2 });
			network.SetInput(in);
			const ml::Vector& out = network.ForwardPropagate();

			const auto grad = learning.CalculateGradient(network, expected);
			learning.Learn(network, grad, alpha);

			const uint64_t idxRes = GetMaxIdx(out.Data(), out.Length());

			const bool succeeded = idxRes == dataset[idx].Idx;

			numTotal++;
			numSucceeded += succeeded ? 1 : 0;
		}
	}
	const double learningAccuracy = double(numSucceeded) / numTotal;

	REQUIRE(learningAccuracy == 0.77544642857142854);

	const std::vector<ml::Vector> utResults = { 
		ml::Vector({2.11803e-05, 0.173698, 0.826281}),
		ml::Vector({0.881053, 0.114871, 0.00407618}),
		ml::Vector({0.881077, 0.114848, 0.00407579}),
		ml::Vector({0.008022, 0.618005, 0.373973}),
		ml::Vector({2.10895e-06, 0.0915491, 0.908449}),
		ml::Vector({0.000360055, 0.350181, 0.649459}),
		ml::Vector({0.881106, 0.114819, 0.00407573}),
		ml::Vector({0.0470335, 0.733552, 0.219415}),
		ml::Vector({0.0255209, 0.704095, 0.270384}),
		ml::Vector({0.881067, 0.11486, 0.00407335}),
	};

	for (int i = 0; i < 10; ++i) {
		int idx = rndSeq[i + 140];

		ml::Vector expected({ 0.0, 0.0, 0.0 });
		expected[dataset[idx].Idx] = 1.0;

		const ml::Vector in({ dataset[idx].Len1, dataset[idx].Wid1, dataset[idx].Len2, dataset[idx].Wid2 });
		network.SetInput(in);
		const ml::Vector& out = network.ForwardPropagate();

		const auto grad = learning.CalculateGradient(network, expected);
		learning.Learn(network, grad, alpha);

		const uint64_t idxRes = GetMaxIdx(out.Data(), out.Length());

		const bool succeeded = idxRes == dataset[idx].Idx;

		REQUIRE((out == utResults[i]));
		REQUIRE(idxRes == dataset[idx].Idx);
	}
}